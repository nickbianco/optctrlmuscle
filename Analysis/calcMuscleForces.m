function forces = calcMuscleForces(a,Lce,Vce, params)
%-------------------------------------------------------------------------------
% Force generated by the contractile element described in the Appendix of van
% Soest and Bobbert (1993).
%
% USAGE
%   [F,Fiso] = calcMuscleForces(a,Lce,Vce, params);
%
% INPUTS
%        a: activation in [0,1]
%      Lce: length of the contractile element [m]
%      Vce: velocity of the contractile element [m/s] (shortening is negative)
%   params: structure array containing muscle parameters
%
% OUTPUTS
%      F: generated force [N]
%   Fiso: the ratio (relative to Fmax) of force that would be generated
%         isometrically at a=1 (e.g., Fiso=1 at Lceopt)
%
% Uchida.1611021431
%-------------------------------------------------------------------------------

% Check parameters.
if (a<0 || a>1), error('Activation must be in [0,1]'); end
if (Lce<0), error('Length of the contractile element cannot be negative'); end
fields = {'width', 'Lceopt', 'Arel', 'Brel', 'Fmax'};
for i = 1:length(fields)
    if (~isfield(params,fields{i}))
        error(['Missing ''',fields{i},''' field in parameters struct']);
    end
end
if (params.width<0), error('Width cannot be negative'); end
if (params.Lceopt<0), error('Optimal fiber length cannot be negative'); end
if (params.Arel<0), error('Arel parameter cannot be negative'); end
if (params.Brel<0), error('Brel parameter cannot be negative'); end
if (params.Fmax<0), error('Maximum isometric force cannot be negative'); end

% Calculate Fiso.
if (Lce >= (1-params.width)*params.Lceopt && ...
    Lce <= (1+params.width)*params.Lceopt)

    c = -1/params.width^2;
    Fiso = c * (Lce/params.Lceopt)^2 - 2*c*(Lce/params.Lceopt) + c + 1;
else
	Fiso = 0;
end

% Calculate F.
if (Vce < 0) %concentric
    Afactor = a^(-0.3);
    Arelstar = params.Arel*Afactor;
    Vstar = -Vce;
    Fnum = -params.Fmax*a*( Vstar*Arelstar - params.Lceopt*params.Brel*Fiso );
    Fden = Vstar + params.Lceopt*params.Brel;
    F = Fnum/Fden;
    
else %eccentric
    a = max(a, 1e-12);
    Afactor = a^(-0.3);
    Arelstar = params.Arel*Afactor;
    Vstar = -Vce;
    c2 = -1.5/a;
	if (abs(Fiso+Arelstar) < 1e-8)
		fprintf('WARNING: about to divide by Fiso+Arelstar = %0.6g\n', ...
                Fiso+Arelstar);
	end
    c1 = 0.5 * (params.Brel*(Fiso+c2)^2)/(Fiso+Arelstar);
    c3 = -0.5 * (params.Brel*(Fiso+c2))/(Fiso+Arelstar);
    Fnum = -params.Fmax*a*(-Vstar*c2 + params.Lceopt*c1 + params.Lceopt*c2*c3);
    Fden = -Vstar + params.Lceopt*c3;
    F = Fnum/Fden;
end

forces = [max(0,F), max(0,Fiso)];
